#!/bin/sh --
# asr - download arch linux build files from the svntogit repositories

# requires git expac pacman pacutils

# Allow variables in printf formatter to expose the DSL
# shellcheck disable=SC2059

error() {
    r=$1 m=$2
    shift 2
    printf "asr: $m" "$@" >&2
    exit "$r"
}

warn() {
    m=$1
    shift
    printf "asr: $m" "$@" >&2
}

clone() {
    pkg=$1

    set -- https://git.archlinux.org/svntogit/packages.git \
           https://git.archlinux.org/svntogit/community.git

    for repo in "$@"; do
        if git ls-remote --exit-code "$repo" refs/heads/packages/"$pkg"; then
            git clone -nb packages/"$pkg" --single-branch "$repo" "$pkg"

            # Break out if we succeed to avoid duplicate packages being found.
            return
        fi
    done

    return 1
}

checkout() {
    if clone "$1" && cd "$1"; then
        git checkout HEAD:trunk -- .
    else
        return
    fi
}

if [ ! "$1" ]; then
    printf 'usage: asr package\n' >&2
    exit 1
fi

# Attempt to blindly checkout the package as this should work in the common
# case.  The error checking is only necessary in a few annoying edge-cases.
if ! checkout "$1"; then
    # Check to see if the package was from a split-package by determining if
    # it has a pkgbase.
    if pkgbase=$(expac -S %e "$1") && [ "$pkgbase" != '(null)' ]; then
        # expac cannot yet be configured to only search specific repositories
        # so it might pass the prior check only to fail here.
        if repo=$(expac -S %r "$pkgbase"); then
            case $repo in
                testing|core|extra) ;;
                community|community-testing) ;;
                multilib|multilib-testing) ;;
                *) error 1 '%s: not an official repository\n' "$repo"
            esac
        fi

        if ! checkout "$pkgbase"; then
            error 1 '%s: checkout failed\n' "$pkgbase"
        fi
    else
        # Sometimes we might get a virtual package.  If the package is
        # provided by only one package then attempt a checkout.
        # Anything greater will require user intervention as otherwise we
        # would have to guess the intention.

        # NOTE: Any nonextant package will fall through to this branch. It
        #       works out in the end as pacsift | wc -l will return zero for
        #       these cases.
        satisfies=$(pacsift --sync --exact --satisfies="$1")

        case $(printf '%s' "$satisfies" | wc -l) in
            0) error 1 '%s: no such package\n' "$1"
               ;;
            1) warn '%s: provided by %s\n' "$1" "$satisfies"

               if ! checkout "${satisfies#*/}"; then
                   error 1 '%s: checkout failed\n' "${satisfies#*/}"
               fi
               ;;
            *) warn '%s: provided by multiple packages:\n' "$1"
               printf '%s\n' "$satisfies" >&2
               exit 1
        esac
    fi
fi
