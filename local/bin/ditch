#!/bin/bash
# ditch - create a menu using the twitch team and stream APIs

# requires jshon bemenu mpv youtube-dl bash(4.3+)
# optional notify-send

# XDG_CONFIG_HOME/dmenu/font     single line containing a font description
# XDG_DATA_HOME/ditch/teams      list of twitch teams
# XDG_DATA_HOME/ditch/streamers  list of individual streamers

readonly argv0=ditch
readonly data_dir=${LOCALDIR:-$HOME/local}/data/$argv0

# Preferred quality in descending order.
readonly quality=High/Medium/best

# Used to store downloaded json.
readonly TMPDIR=${TMPDIR:-/tmp}

# Number of entries to display at once.
readonly lines=30

read -r font < "${LOCALDIR:-$HOME/local}/cfg/dmenu/font"

bemenu_args=(
    --fn "$font" -w -i -l "$lines"
    --tf '#eff1f5' --tb '#bf616a'
    --ff '#c0c5ce' --fb '#2b303b'
    --sf '#bf616a' --sb '#343d46'
    --nf '#65737e' --nb '#343d46'
    --hf '#c0c5ce' --hb '#343d46'
    --scf '#65737e' --scb '#343d46'
    -p 'STREAM' --scrollbar autohide
)

has() {
    hash "$1" 2> /dev/null
}

print() {
    printf -- "$1\n" "${@:2}"
}

err() {
    print "$argv0: $1" "${@:2}" >&2

    if has notify-send; then
        local msg
        msg=$(print "$@")
        notify-send -u critical -- "$argv0" "$msg"
    fi
}

chunk_by() {
    declare chunk=$1
    declare -n list_r=$2

    # I purposefully use &limit=chunk here as a marker later on to separate out
    # twitch's API versions.  The team (v2) API is exactly the same in terms of
    # what I want, but the streamers (v3) API changes the key identifiers thus
    # making it incompatible, for nothing, joyless.
    print '%s' "${list_r[@]}" | xargs -n "$chunk" | sed "s/ /,/g; s/$/&\&limit=$chunk/"
}

generate_urls() {
    declare team list chunk nelem

    if [[ -s $data_dir/streamers ]]; then
        mapfile -t list < "$data_dir"/streamers

        # Twitch lets us use a maximum of 100 streamers per query.
        chunk=100
        nelem=${#list[@]}

        if ((nelem < chunk)); then
            chunk_by "$nelem" list
        else
            chunk_by "$chunk" list
        fi
    fi
}

# Runs a function over the each element of an array in the background and waits
# for all to complete before returning.
parallel_fmap() {
    declare func=$1
    declare -n array_r=$2

    for i in "${array_r[@]}"; do
        "$func" "$i" &
    done

    wait
}

# Download the json associated with a twitch team name or comma separated list
# of streamers, with &limit= appended to the end.
fetch_json() {
    declare a=$1
    declare stream data

    data=$(mktemp -t "$argv0"-channels-XXX.json)
    curl -s "https://api.twitch.tv/kraken/streams?channel=$a" > "$data"
}

# Parsed json is printed in series of three lines, the first is the username,
# then the url to their stream and finally the title.
parse_json() {
    declare json args

    for json in "$TMPDIR/$argv0"-channels*; do
        args=(-CQ -e streams -a -e channel -e name -upe game -upe url -upe status)
        jshon "${args[@]}" < "$json"
    done

    # Make sure we remove the json once we're done so it doesn't interfere with
    # proceeding execution and doesn't clutter up $TMPDIR.
    rm -f -- "$TMPDIR/$argv0"-channels-*.json
}

create_menu() {
    declare -n menu_r=$1
    declare -n stream_r=$2
    declare streamer game url title

    while {
        read -r streamer
        read -r game
        read -r url
        read -r title
    } do
        # jshon(1) -C will return null for keys without values (or missing keys
        # entirely), since a valid url can never be null we'll use this as a
        # sentinel for bad values and skip any we find.
        if [[ $url != null ]]; then

            # Manually de-json the title.
            # XXX This doesn't handle all json escapes but we don't need to.
            title="${title%\"*}" title="${title#\"}" title="${title//\\/}"

            menu_r["$streamer│$game│$title"]=1
            stream_r["$streamer"]="$url"
        fi
    done
}

get_user_picks() {
    declare -n menu_r=$1
    declare -n stream_r=$2

    # Using a marker here for column to pretty print the results in columns,
    # here's hoping not many people use this in their titles, generally this
    # hasn't been the case and it won't cause issues as only the first word is
    # used and that is guaranteed to not contain spaces.
    print '%s' "${!menu_r[@]}" | column -s '│' -t  | bemenu "${bemenu_args[@]}"
}

play_stream() {
    declare url=$1
    declare title=$2
    declare err args

    shopt -s extglob
    # Squeeze repeated spaces.
    args=(--quiet --title="MPV:${title//+( )/ }")

    if [[ $quality ]]; then
        args+=(--ytdl-format="$quality")
    fi

    if ! err=$(mpv "${args[@]}" "$url"); then
        err '%s' "${err:-mpv}"
    fi
}

play_if_valid() {
    declare -n stream_r=$1
    declare streamer title url

    while read -r streamer title; do
        [[ ! $title ]] && title="$streamer"

        # Check if the selection actually matches a stream.
        if [[ ${stream_r[$streamer]} ]]; then
            url=${stream_r[$streamer]}
        else
            err '%s: cannot find associated stream' "$streamer"
            exit 1
        fi

        play_stream "$url" "$title" &
    done
}

case $1 in
    -u)
        # Basic option added simply so I can update any teams now and then,
        # they're fairly static so this shouldn't need to be run very often.
        # XXX I don't, and won't, deal with cache invalidation here.
        if [[ -s $data_dir/teams ]]; then
            while read -r t; do
                print 'processing %s' "$t" >&2

                # As an API for listing all channels belonging to a team isn't
                # available anymore, we simply scrape in the meantime until it
                # is fixed.  <https://github.com/justintv/Twitch-API/issues/99>
                curl -s "https://www.twitch.tv/team/$t" | sed -rn '/member_name/ { s/.*>(.*)<.*/\1/p }'
            done < "$data_dir"/teams >> "$data_dir"/streamers

            sort -u "$data_dir"/streamers -o "$data_dir"/streamers
        fi
        ;;
    *)
        mapfile -t urls < <(generate_urls)

        if ((${#urls} > 0)); then
            parallel_fmap fetch_json urls
        else
            err 'no configuration data found'
            exit 1
        fi

        declare -A menu stream
        create_menu menu stream < <(parse_json)

        results=$(get_user_picks menu stream)

        if [[ $results ]]; then
            play_if_valid stream <<< "$results"
        fi
esac
