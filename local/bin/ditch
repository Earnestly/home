#!/bin/bash
# ditch - create a menu using the twitch team and stream APIs

# requires jshon bemenu mpv youtube-dl bash(4.3+)
# optional notify-send

# LOCALDIR/cfg/dmenu/font        single line containing a font description
# LOCALDIR/data/ditch/teams      list of twitch teams
# LOCALDIR/data/ditch/streamers  list of individual streamers

readonly argv0=ditch
readonly data_dir=${LOCALDIR:-$HOME/local}/data/$argv0

# Preferred quality in descending order, unset to use mpv/youtube-dl default.
readonly quality=High/Medium/best

# Used to store downloaded json.
readonly TMPDIR=${TMPDIR:-/tmp}

# Number of entries to display at once.
readonly lines=30

# Backup: jzkbprff40iqj646a697cyrvl0zt2m6 (youtube-dl)
readonly client_id=rfbp97unyyikyzw1y9cy87iii29lgjk

read -r font < "${LOCALDIR:-$HOME/local}"/cfg/dmenu/font

bemenu_args=(
    --fn "$font" -w -i -l "$lines"
    --tf '#eff1f5' --tb '#bf616a'
    --ff '#c0c5ce' --fb '#2b303b'
    --sf '#bf616a' --sb '#343d46'
    --nf '#65737e' --nb '#343d46'
    --hf '#c0c5ce' --hb '#343d46'
    --scf '#65737e' --scb '#343d46'
    -p 'STREAM' --scrollbar autohide
)

has() {
    hash "$1" 2> /dev/null
}

print() {
    printf -- "$1\n" "${@:2}"
}

err() {
    print "$argv0: $1" "${@:2}" >&2

    if has notify-send; then
        local msg
        msg=$(print "$@")
        notify-send -u critical -- "$argv0" "$msg"
    fi
}

chunk_by() {
    declare -i chunk=$1
    declare -n list_r=$2

    print '%s' "${list_r[@]}" | xargs -n "$chunk" | sed "s/ /,/g; s/$/&\&limit=$chunk/"
}

generate_urls() {
    declare team list chunk nelem

    if [[ -s $data_dir/streamers ]]; then
        mapfile -t list < "$data_dir"/streamers

        # Twitch lets us use a maximum of 100 streamers per query.
        chunk=100
        nelem=${#list[@]}

        if ((nelem < chunk)); then
            chunk_by "$nelem" list
        else
            chunk_by "$chunk" list
        fi
    fi
}

# Runs a function over the each element of an array in the background and waits
# for all to complete before returning.
parallel_apply() {
    declare func=$1
    declare -n array_r=$2

    for i in "${array_r[@]}"; do
        "$func" "$i" &
    done

    wait
}

# Download the json associated with a twitch team name or comma separated list
# of streamers, with &limit= appended to the end.
fetch_json() {
    declare a=$1
    declare stream data
    declare url=https://api.twitch.tv/kraken/streams?channel=$a

    data=$(mktemp -t "$argv0"-channels-XXX.json)
    curl -sH "Client-ID: $client_id" "$url"  > "$data"
}

# Parsed json is printed in series of six lines, the first is the number of
# viewers on which we can order the results then the streamer, game being
# played, url to their stream, and finally the title of the stream.
parse_json() {
    declare json args

    args=(-CQ
          -e streams -a
          -e viewers -upe channel -e name -upe game -upe url -upe status)

    for json in "$TMPDIR/$argv0"-channels*; do
        jshon "${args[@]}" < "$json"
    done

    # Make sure we remove the json once we're done so it doesn't interfere with
    # proceeding execution and doesn't clutter up $TMPDIR.
    rm -f -- "$TMPDIR/$argv0"-channels-*.json
}

create_menu() {
    declare -n menu_r=$1
    declare -n stream_r=$2
    declare viewers streamer game url title

    while {
        read -r viewers
        read -r streamer
        read -r game
        read -r url
        read -r title
    } do
        # jshon(1) -C will return null for keys without values (or missing keys
        # entirely), since a valid url can never be null we'll use this as a
        # sentinel for bad values and skip any we find.
        if [[ $url != null ]]; then
            menu_r["$streamer│$game│($viewers) ${title//[\"\\]/}"]=1
            stream_r[$streamer]=$url
        fi
    done
}

get_user_picks() {
    declare -n menu_r=$1
    declare -n stream_r=$2

    # Using a marker here for column to pretty print the results in columns,
    # here's hoping not many people use this in their titles, generally this
    # hasn't been the case and it won't cause issues as only the first word is
    # used and that is guaranteed to not contain spaces.
    print '%s' "${!menu_r[@]}" | column -s '│' -t | sort -srnk 2,2 -t '('
}

play_stream() {
    declare url=$1
    declare title=$2
    declare err args

    shopt -s extglob
    # Squeeze repeated spaces.
    args=(--quiet --title="MPV:${title//+( )/ }")

    if [[ $quality ]]; then
        args+=(--ytdl-format="$quality")
    fi

    if ! err=$(mpv "${args[@]}" "$url"); then
        err '%s' "${err:-mpv}"
    fi
}

play_if_valid() {
    declare -n stream_r=$1
    declare streamer title url

    while read -r streamer title; do
        if [[ ! $title ]]; then
            title=$streamer
        fi

        # XXX This is likely not necessary; the fallback could become the norm
        if [[ ${stream_r[$streamer]} ]]; then
            url=${stream_r[$streamer]}
        else
            # Fallback.
            url=https://twitch.tv/$streamer
        fi

        play_stream "$url" "$title" &
    done
}

case $1 in
    -u)
        # Basic option added simply so I can update any teams now and then,
        # they're fairly static so this shouldn't need to be run very often.
        # XXX I don't, and won't, deal with cache invalidation here.
        if [[ -s $data_dir/teams ]]; then
            while read -r t; do
                print 'processing %s' "$t" >&2

                # As an API for listing all channels belonging to a team isn't
                # available anymore, we simply scrape in the meantime until it
                # is fixed.  <https://github.com/justintv/Twitch-API/issues/99>
                curl -s "https://www.twitch.tv/team/$t" | sed -rn '/member_name/ { s/.*>(.*)<.*/\1/p }'
            done < "$data_dir"/teams >> "$data_dir"/streamers

            sort -u "$data_dir"/streamers -o "$data_dir"/streamers
        fi
        ;;
    *)
        mapfile -t urls < <(generate_urls)

        if ((${#urls} > 0)); then
            parallel_apply fetch_json urls
        else
            err 'no configuration data found'
            exit 1
        fi

        declare -A menu stream
        create_menu menu stream < <(parse_json)

        results=$(get_user_picks menu stream | bemenu "${bemenu_args[@]}")

        if [[ $results ]]; then
            play_if_valid stream <<< "$results"
        fi
esac
