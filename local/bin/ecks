#!/bin/sh --
# ecks - dead simple combination of xinit and startx

# requires Xorg xset xhost

trap 'cleanup "$pid"' EXIT

readonly stty=$(stty -g)

error() {
    # shellcheck disable=SC2059
    printf -- "ecks: $2" "${@:3}" >&2
    exit "$1"
}

cleanup() {
    kill "$1"

    # Send SIGKILL after 10 seconds if the xserver is taking too long to
    # terminate.
    timeout 10 tail --pid="$1" -f /dev/null

    case $? in
        124) kill -s KILL "$1"
    esac

    if ! stty "$stty"; then
        stty sane
    fi

    xauth remove :"$tty"

    exit
}

readonly localdir=${LOCALDIR:-$HOME/local}

readonly cfgdir=$localdir/cfg/ecks
readonly logdir=$localdir/var/log/ecks
readonly datadir=$localdir/data/ecks

readonly ecksrc=$cfgdir/ecksrc
readonly XAUTHORITY=$datadir/xauthority

mkdir -p "$cfgdir" "$logdir" "$datadir"

if [ "$DISPLAY" ]; then
    error 1 '%s: DISPLAY already present\n' "$DISPLAY"
fi

if [ ! -x "$ecksrc" ]; then
    error 1 '%s: not found or not executable\n' "$ecksrc"
fi

if ! tty=$(fgconsole); then
    exit
fi

if [ ! -f "$XAUTHORITY" ]; then
    # shellcheck disable=SC2188
    > "$XAUTHORITY"
fi

export XAUTHORITY

# NOTE: Clobbers existing entries.
xauth add :"$tty" MIT-MAGIC-COOKIE-1 "$(mcookie)"

/usr/lib/xorg-server/Xorg :"$tty" vt"$tty" -logfile "$logdir"/"$tty" \
    -auth "$XAUTHORITY" -keeptty & pid=$!

export DISPLAY=:$tty

# Wait for the xserver to become available before continuing.
# nb. This is the same logic xinit(1) uses.
attempts=120
until xset q > /dev/null 2>&1; do
    if [ "$attempts" -gt 0 ]; then
        attempts=$((attempts - 1))
    else
        error 1 '%s: failed to connect to the server, giving up\n' "$DISPLAY"
    fi
done

if ! "$ecksrc"; then
    exit
fi

case $(ps -o comm= "$pid") in
    Xorg) cleanup "$pid"
esac
