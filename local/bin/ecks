#!/bin/sh --
# ecks - dead simple combination of xinit and startx

# requires Xorg xset xauth timeout signore

trap 'cleanup "$pid"' EXIT
trap 'ready=1' USR1

error() {
    # shellcheck disable=SC2059
    printf -- "ecks: $2" "${@:3}" >&2
    exit "$1"
}

cleanup() {
    if [ "$(ps -o comm= "$1")" = Xorg ]; then
        kill "$1"

        # Send SIGKILL after 10 seconds if the xserver is taking too long to
        # terminate.
        timeout 10 tail --pid="$1" -f /dev/null

        case $? in
            124) kill -s KILL "$1"
        esac

        xauth remove :"$tty"
    fi

    if ! stty "$stty"; then
        stty sane
    fi

    exit
}

if ! readonly stty=$(stty -g); then
    exit
fi

if ! readonly tty=$(fgconsole); then
    exit
fi

readonly localdir=${LOCALDIR:-$HOME/local}

readonly cfgdir=$localdir/cfg/ecks
readonly logdir=$localdir/var/log/ecks
readonly datadir=$localdir/data/ecks

readonly ecksrc=$cfgdir/ecksrc
readonly XAUTHORITY=$datadir/xauthority

mkdir -p "$cfgdir" "$logdir" "$datadir"

if [ "$DISPLAY" ]; then
    error 1 '%s: DISPLAY already set\n' "$DISPLAY"
fi

if [ ! -x "$ecksrc" ]; then
    error 1 '%s: not executable\n' "$ecksrc"
fi

touch "$XAUTHORITY"
export XAUTHORITY

# Clobber existing entries.
xauth add :"$tty" MIT-MAGIC-COOKIE-1 "$(mcookie)"

# The Xorg process will notice SIGUSR1 being set to SIG_IGN and issue its own
# SIGUSR1 back to us when ready to accept connections.  So we listen for the
# returning SIGUSR1 as an indication to continue.
signore USR1 /usr/lib/xorg-server/Xorg :"$tty" \
    -keeptty vt"$tty" \
    -logfile "$logdir/$tty" \
    -auth "$XAUTHORITY" &

pid=$!

until [ "${ready:-0}" -eq 1 ]; do
    sleep 1
done

export DISPLAY=:$tty

"$ecksrc"

exit
