#!/usr/bin/env bash
# ~/.local/bin/ditch
# Create a dmenu using the twitch team and stream APIs.
# Requires jshon, dmenu-imlib-pango (for -w), livestreamer

# Files
# ~/.config/ditch/teams      List of twitch teams.
# ~/.config/ditch/streamers  List of individual streamers.

readonly progn=ditch
readonly data_dir="${XDG_CONFIG_HOME:-$HOME/.config}"/ditch

# Used to store downloaded json.
readonly TMPDIR="${TMPDIR:-/tmp}"

# Options passed to dmenu, the `-p` prompt is passed later, remove `-w` if you
# use plain old dmenu.
dmenu_opts=(-fn 'Dina Bold 8' -w -i -l 40
            -nf '#a7a7a7' -nb '#1e1e1e'
            -sf '#9b859d' -sb '#262626')

puts() {
    local fmt="$1"; shift

    printf -- "$fmt\n" "$@"
}

err() {
    local msg

    # Use notify-send if it exists and we're not running from a terminal.
    if [[ ! -t 0 ]] && hash notify-send &> /dev/null; then
        msg="$(puts "$@")"
        notify-send -u critical -- "$progn" "$msg"
    else
        puts "$progn: $@" >&2 
    fi
}

get_user_data() {
    local team list chunk nelem tmp

    if [[ -s "$data_dir"/teams ]]; then
        while read -r team; do
            puts '%s' "$team"
        done < "$data_dir"/teams
    fi

    if [[ -s "$data_dir"/streamers ]]; then
        mapfile -t list < "$data_dir"/streamers

        # Twitch lets us use a maximum of 100 streamers per query.
        chunk=100
        nelem=${#list[@]}

        if ((nelem < chunk)); then
            printf -- '%s,' "${list[@]}"
            puts '&limit=%d' $nelem
        else
            while ((${#list[@]})); do
                # Assuming chunks of 2, the following occurs on [1 2 3 4 5]:
                # 1st loop: [{ 1 2 } 3 4 5]  => 1,2,
                # 2nd loop: [{ 3 4 } 5]      => 3,4,
                # 3rd loop: [{ 5 }]          => 5,
                printf -- '%s,' "${list[@]::$chunk}"

                tmp=("${list[@]::$chunk}")
                puts'&limit=%d' ${#tmp[@]}

                # 1st loop: [ 1 2 { 3 4 5 }] => list = [3 4 5]
                # 2nd loop: [ 3 4 { 5 }]     => list = [5]
                # 3rd loop: [ 5 { }]         => done
                list=("${list[@]:$chunk}")
            done
        fi
    fi
}

# Download all the json chunks to individual files, each file will be read
# sequentially later but this allows me to (fork) background this function.
get_json() {
    local s="$1"
    local stream data

    data="$(mktemp -t "$progn"-XXX.json)"

    # Streams always have a `&limit=` appended.
    if [[ "$s" =~ \&limit= ]]; then
        curl -sLG "https://api.twitch.tv/kraken/streams?channel=$s" > "$data"
    else
        curl -sLG "http://api.twitch.tv/api/team/$s/live_channels.json" > "$data"
    fi
}

parse_json() {
    # Try both API versions at the same time using '-C'ontinue, if the first (v2)
    # path fails, pop everything off (-ppp) and try the other (v3).
    local args=(-QC  -e channels -a -e channel -e name -upe link -upe title  -j
                -ppp -e streams  -a -e channel -e name -upe url  -upe status -j)
    local i json

    # Fire off all the curl calls as soon as possible
    for i in "${twitch_list[@]}"; do
        get_json "$i" &
    done

    # Wait for all the get_json jobs to finish before continuing.
    wait

    for i in "$TMPDIR"/*.json; do
        jshon "${args[@]}" < "$i"

        # Make sure we remove the json once we're done so it doesn't interfere
        # with proceeding runs and doesn't clutter up `$TMPDIR`.
        rm -rf -- "$i"
    done
}

play_stream() {
    local url="$1"
    local title="$2"
    local err

    # Strip out any single quotes from the title, not very elegant but bash
    # offers no other way to embed variables in literal strings.
    lstreamer_opts=(
        --player "mpv  --title='${title//\'/â€™}' --profile=live"
        --quiet
        "$url"
    )

    # Capture the error so we can display it elsewhere.
    if ! err="$(livestreamer "${lstreamer_opts[@]}")"; then
        err '%s\n' "$err"
    fi
}

# Unconditionally create the data directory.  If it already exists `mkdir` is a
# no-op.
mkdir -p "$data_dir"

declare -A stream menu
declare -a twitch_list

mapfile -t twitch_list < <(get_user_data)

# If no user data was found to generate anything from, just exit.
if [[ -z "${twitch_list[@]}" ]]; then
    err 'No configuration data found.'
    exit 1
fi

# First line is always the streamer's name, followed by the url and then the
# streamer's title.
while {
    read -r name
    read -r url
    read -r title
} do
    # Manually de-json the title.
    title="${title%\"*}" title="${title#\"}" title="${title//\\/}"

    # `menu` is what we will use for displaying via dmenu, we will later
    # extract the first word from the result which is `$name` used as the
    # key for `streams`.
    menu["$name $title"]=1 # Store only unique results using a "set".
    stream["$name"]="$url"
done < <(parse_json)

# This is necessary to remove the key "null null" from the menu set we are
# likely to have collected at least one during the forced json extraction.
# XXX This assumes the user 'null' doesn't stream with the title 'null', if
#     they do then they will simply be excluded from the results.
unset -v menu["null null"]

# Display the number of current streams in dmenu's prompt.
dmenu_opts+=(-p "Stream ${#stream[@]}")

# Use awk to pretty-print the user and title in 2 columns.
# XXX This doesn't work so well for non-proportional fonts.
awk='{ a = $1; $1 = ""; printf "%-25s %s\n", a, $0 }'
results="$(puts '%s' "${!menu[@]}" | awk "$awk" | dmenu "${dmenu_opts[@]}")"

# Exit if nothing was selected.
if [[ -z "$results" ]]; then
    exit
fi

# The first element is always the streamer, followed by the title.
while read -r streamer title; do

    # If the title is unset just use the streamer's name instead.
    if [[ -z "$title" ]]; then
        title="$streamer"
    fi

    # Check if the selection actually matches a stream.
    if [[ -n "${stream[$streamer]}" ]]; then
        url="${stream[$streamer]}"
    else
        err '%s: Cannot find associated stream.' "$streamer"
        exit 1
    fi

    # Fire off all in the background, this will still warn on failure.
    play_stream "$url" "$title" &
done <<< "$results"
