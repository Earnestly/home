#!/bin/bash
# ~/.local/bin/ditch
# Create a dmenu using the twitch team and stream api
# Requires jshon, dmenu-imlib-pango

# Files
# ~/.config/ditch/teams         list of twitch teams
# ~/.config/ditch/streamers     list of individual streamers

# Options
shopt -s extglob

# Globals
data_dir="${XDG_CONFIG_HOME:-$HOME/.config}"/ditch

# Make sure it exists
if ! [[ -d "$data_dir" ]]; then
    mkdir "$data_dir"
fi

# Used to collect downloaded json
TMPDIR="${TMPDIR:-/tmp}"

# Stream quality, each will be attempted in order and falls back to the next
quality='medium,high,best,source'

# Options passed to dmenu, the `-p` prompt is passed later, remove `-w` if you
# use plain old dmenu
dmenu_opts=(-fn 'Dina Bold 8' -w -i -l 40
            -nf '#a7a7a7' -nb '#1e1e1e'
            -sf '#9b859d' -sb '#262626')

get_user_data() {
    local team list chunk nelem i

    # Get the list of teams, prepend each element with t: so we can use it later
    # to call the correct API
    if [[ -s "$data_dir"/teams ]]; then
        while read -r team; do
            printf '%s\n' "$team"
        done < "$data_dir"/teams
    fi

    if [[ -s "$data_dir"/streamers ]]; then
        # Even though twitch lets us use up to chunks of 100, curl will fail
        # due to the argument being too long.  Setting this to 15 seems to be
        # reasonable but may cause problems if each streamer has a very long
        # username
        mapfile -t list < "$data_dir"/streamers

        chunk=15
        nelem="${#list[@]}"

        if ((nelem < 10)); then
            for ((i = 0; i < nelem; i++)); do
                printf '%s,' "${list[$i]}"
            done
            printf '&limit=%d\n' "${#list[@]}"
        else
            while ((${#list[@]})); do
                printf '%s,' "${list[@]::$chunk}"

                tmp=(${list[@]::$chunk})
                printf '&limit=%d\n' "${#tmp[@]}"

                list=(${list[@]:$chunk})
            done
        fi
    fi
}

mapfile -t twitch_list < <(get_user_data)

# Download all the json to individual files, each file will be read sequentially
# later, but this allows me to background this function
get_json() {
    local s="$1"
    local stream

    local data="$TMPDIR"/"$s".json

    # streams always have a `&limit=` appended
    if [[ "$s" == *'&limit=' ]]; then
        curl -s https://api.twitch.tv/kraken/streams?channel="${s#*:}" > "$data"

        # Use sed to normalise the API with v2
        # XXX Assumes that the matched tokens never appear elsewhere.
        sed -i '{
            s/"streams":/"channels":/g;
            s/"url":"/"link":"/g;
            s/"status":"/"title":"/g
        }' "$data"
    else
        curl -s http://api.twitch.tv/api/team/"${s#*:}"/live_channels.json > "$data"
    fi
}

parse_json() {
    # Make sure to not (-u) 'unstring' the title as it may contain valid escapes
    # which break the strict ordering requirements for the while read loop.  We will
    # manually de-string the titles later.
    local jshon_opts=(-e channels -a -e channel -e display_name -upe link -upe title)
    local i json

    # Fire off all the curl calls as soon as possible
    for i in "${twitch_list[@]}"; do
        get_json "$i" &
    done

    # Wait for all the get_json jobs to finish before continuing
    wait

    for i in "$TMPDIR"/*.json; do
        jshon "${jshon_opts[@]}" < "$i"

        # Make sure we remove the json once we're done so it doesn't interfere
        # with proceeding runs and doesn't clutter up /tmp
        rm -rf "$i"
    done
}

declare -A streams

# First line is always the streamer's name, followed by the url and then the
# streamer's title
while {
    read -r name
    read -r url
    read -r title
}; do
    # Manually de-quote the title and remove backslashes
    title="${title%\"*}" title="${title#\"}" title="${title//\\/}"

    # Store the name and title for dmenu to display as the key in an associative
    # array where the url is the value.
    if [[ "$name" != http* ]]; then
        streams["$name $title"]="$url"
    fi
done < <(parse_json)

# Display the number of current streams in dmenu's prompt
dmenu_opts+=(-p "Streams (${#streams[@]})")

# Use awk to pretty print the user and title in a column
awk='{ a = $1; $1 = ""; printf "%-20s %s\n", a, $0}'

# Display the keys and store it as the selection
selection="$(printf '%s\n' "${!streams[@]}" | awk "$awk" | dmenu "${dmenu_opts[@]}")"

# Rebuild the result without the column spacing awk added
if [[ "$selection" =~ ([^ ]+)(.*) ]]; then
    selection="${BASH_REMATCH[1]} ${BASH_REMATCH[2]##*( )}"
fi

# Check if the selection actually matches a stream, this will also exit if
# nothing was selected
if [[ -z "$selection" || -z "${streams[$selection]}" ]]; then
    exit
fi

# Strip out any single quotes from the title, this is ugly though, very ugly.
lstreamer_opts=(
    -Q
    -p "mpv --really-quiet --title='${selection//\'/â€™}' --profile=live"
    --ringbuffer-size 800000
    "${streams[$selection]}"
    "$quality"
)

# Pass the value based on the key from selectionection to livestreamer
if ! livestreamer "${lstreamer_opts[@]}"; then
    if hash i3-nagbar &> /dev/null; then
        i3-nagbar -m "Failed to launch stream ${streams[$selection]}" -t error
    fi
    exit 1
fi
