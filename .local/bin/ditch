#!/usr/bin/env bash
# ~/.local/bin/ditch
# Create a dmenu using the twitch team and stream api
# Requires jshon, dmenu-imlib-pango

# Files
# ~/.config/ditch/teams         list of twitch teams
# ~/.config/ditch/streamers     list of individual streamers

# Globals
readonly data_dir="${XDG_CONFIG_HOME:-$HOME/.config}"/ditch

# Make sure it exists
if ! [[ -d "$data_dir" ]]; then
    mkdir -p "$data_dir"
fi

# Used to collect downloaded json
readonly TMPDIR="${TMPDIR:-/tmp}"

# Options passed to dmenu, the `-p` prompt is passed later, remove `-w` if you
# use plain old dmenu
dmenu_opts=(-fn 'Dina Bold 8' -w -i -l 50
            -nf '#a7a7a7' -nb '#1e1e1e'
            -sf '#9b859d' -sb '#262626')

fail() {
    local prefix="$1"
    shift

    # Use notify-send if it exists and we're not running from a terminal
    if [[ ! -t 0 ]] && hash notify-send &> /dev/null; then
        notify-send -u critical "$prefix" "$@"
    else
        printf '[ERROR] %s: %s\n' "$prefix" "$@" >&2
    fi
}

get_user_data() {
    local team list chunk nelem tmp

    if [[ -s "$data_dir"/teams ]]; then
        while read -r team; do
            printf '%s\n' "$team"
        done < "$data_dir"/teams
    fi

    if [[ -s "$data_dir"/streamers ]]; then
        mapfile -t list < "$data_dir"/streamers

        # Twitch lets us use a maximum of 100 streamers per query
        chunk=100
        nelem="${#list[@]}"

        if ((nelem < chunk)); then
            printf '%s,' "${list[@]}"
            printf '&limit=%d\n' "$nelem"
        else
            while ((${#list[@]})); do
                # Assuming chunks of 2, the following occurs on [1 2 3 4 5]
                # 1st loop: [{ 1 2 } 3 4 5]  => 1,2,
                # 2nd loop: [{ 3 4 } 5]      => 3,4,
                # 3rd loop: [{ 5 }]          => 5,
                printf '%s,' "${list[@]::$chunk}"

                tmp=("${list[@]::$chunk}")
                printf '&limit=%d\n' "${#tmp[@]}"

                # 1st loop: [ 1 2 { 3 4 5 }] => list = [3 4 5]
                # 2nd loop: [ 3 4 { 5 }]     => list = [5]
                # 3rd loop: [ 5 { }]         => done
                list=("${list[@]:$chunk}")
            done
        fi
    fi
}

# Download all the json to individual files, each file will be read sequentially
# later, but this allows me to background this function
get_json() {
    local s="$1"
    local stream data

    data="$(mktemp -t ditch-XXX.json)"

    # streams always have a `&limit=` appended
    if [[ "$s" =~ \&limit= ]]; then
        curl -sLG "https://api.twitch.tv/kraken/streams?channel=$s" > "$data"

        # Use sed to normalise the API with v2
        # XXX This assumes that the matched tokens never appear elsewhere.
        sed -i '{
            s/"streams":/"channels":/g;
            s/"url":"/"link":"/g;
            s/"status":"/"title":"/g
        }' "$data"
    else
        curl -sLG "http://api.twitch.tv/api/team/$s/live_channels.json" > "$data"
    fi
}

parse_json() {
    # Make sure to not (-u) 'unstring' the title as it may contain valid escapes
    # which break the strict ordering requirements for the while read loop.  We
    # will manually de-string the titles later.
    local args=(-e channels -a -e channel -e display_name -upe link -upe title)
    local i json

    # Fire off all the curl calls as soon as possible
    for i in "${twitch_list[@]}"; do
        get_json "$i" &
    done

    # Wait for all the get_json jobs to finish before continuing
    wait

    for i in "$TMPDIR"/*.json; do
        jshon "${args[@]}" < "$i"

        # Make sure we remove the json once we're done so it doesn't interfere
        # with proceeding runs and doesn't clutter up /tmp
        rm -rf "$i"
    done
}

play_stream() {
    local url="$1"
    local title="$2"
    local err

    # Strip out any single quotes from the title, not very elegant
    lstreamer_opts=(
        --player "mpv --no-terminal --title='${title//\'/â€™}' --profile=live"
        --player-continuous-http
        --quiet
        "$url"
    )

    # Capture the error so we can display it elsewhere
    if ! err="$(livestreamer "${lstreamer_opts[@]}")"; then
        fail "$url" "$err"
    fi
}

declare -A stream menu
declare -a twitch_list

mapfile -t twitch_list < <(get_user_data)

# If no user data was found to generate anything from, just exit
if [[ -z "${twitch_list[@]}" ]]; then
    fail "ditch" "No configuration data found"
    exit 1
fi

# First line is always the streamer's name, followed by the url and then the
# streamer's title
while {
    read -r name
    read -r url
    read -r title
} do
    # Manually de-json the title
    title="${title%\"*}" title="${title#\"}" title="${title//\\/}"

    if [[ "$name" != http* ]]; then

        # `menu` is what we will use for displaying via dmenu, we will later
        # extract the first word from the result which is `$name` used as the
        # key for `streams`
        menu["$name $title"]=1 # Store only unique results using a "set"
        stream["$name"]="$url"
    fi
done < <(parse_json)

# Display the number of current streams in dmenu's prompt
dmenu_opts+=(-p "Stream ${#stream[@]}")

# Use awk to pretty-print the user and title in 2 columns
awk='{ a = $1; $1 = ""; printf "%-25s %s\n", a, $0 }'
results="$(printf '%s\n' "${!menu[@]}" | awk "$awk" | dmenu "${dmenu_opts[@]}")"

# Exit if nothing was selected
if [[ -z "$results" ]]; then
    exit
fi

while read -r result; do
    # Get the username from the result of dmenu, this is the first word
    # (usernames cannot have spaces) to index our `stream` array
    if [[ "$result" =~ ([^ ]+) ]]; then
        streamer="${BASH_REMATCH[1]}"
    fi

    # Build the title which is always after the first set of spaces, then
    # prefix it with the streamer's name just because we can or just the
    # streamer if there's no title
    if [[ "$result" =~ \ +(.*) ]]; then
        if [[ -n "${BASH_REMATCH[1]}" ]]; then
            title="$streamer: ${BASH_REMATCH[1]}"
        else
            title="$streamer"
        fi
    fi

    # Check if the selection actually matches a stream
    if [[ -n "${stream[$streamer]}" ]]; then
        url="${stream[$streamer]}"
    else
        fail "$streamer" "Cannot find associated stream"
        exit 1
    fi

    # Fire off all in the background, this will still warn on failure
    play_stream "$url" "$title" &
done <<< "$results"
