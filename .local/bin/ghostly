#!/usr/bin/env bash
# ghostly - Uses ghostscript to fix pdf files and generate dmenu_loader menus

# Requires ghostscript (gs)
# Requires poppler (pdfinfo)
# Requires xdg-utils (xdg-mime)

# Globals
readonly TMPDIR=/tmp
readonly current_pdf_version=1.7
readonly library="$HOME"/docs/pdf

usage() {
    cat >&2 <<EOF
Usage: ghostly [options] [pdf, dir]
       ghostly add [options] <pdf>
       ghostly list <pdf>

Options:
    -g      Generate a dmenu_loader compatible menu
    -h      This help message

    add:
        -n      Noclobber, avoid overwriting original document if output matches
                input locations.  Generates a .new file instead
        -o      Output directory (Default: HOME/docs/pdf)
        -t      Insert a title or overrides any current title if the input is
                the same file as the output

    info:
        Display metadata with pdfinfo

EOF
}

is_valid_pdf() {
    local pdf="$1"

    if [[ -n "$pdf" && $(file -biL -- "$pdf") == application/pdf* ]]; then
        return 0
    else
        return 1
    fi
}

info() {
    while (($#)); do
        case "$1" in
            *) pdf="$1"
        esac
        shift
    done

    if is_valid_pdf "$pdf"; then
        pdfinfo "$pdf"
    fi
}

run_ghostscript() {
    # WooOOooOoo

    local input="$1"
    local version="$2"
    local pdfmark="$3"
    local output="$4"
    local -a options

    options=(-sDEVICE=pdfwrite -dBATCH -dNOPAUSE
             -dCompatibilityLevel="$version"
             -sOutputFile="$output"
             -dAutoRotatePages=/None
             -dAutoFilterGrayImages=false
             -dAutoFilterColorImages=false
             -dGrayImageFilter=/FlateEncode
             -dMonoImageFilter=/FlateEncode
             -dColorImageFilter=/FlateEncode)

    if ! gs "${options[@]}" "$input" "$pdfmark"; then
        printf >&2 'gs failure (%d).\n' "$?"
        rm -f "$pdfmark" "$output"
    else
        rm -f "$pdfmark"
    fi

}

pdf_version() {
    local input="$1"

    while IFS=: read -r k v; do
        if [[ "$k" == "PDF version" ]]; then
            printf '%1.1f\n' "$v"
        fi
    done < <(pdfinfo "$input")
}

is_valid_dir() {
    local input="$1"

    # Make sure that what the user sets is valid
    if [[ -n "$input" && ! -d "$input" ]]; then
        return 1
    fi
}

fsize() {
    local input="$1"
    
    size="$(stat -c '%s' "$input")" 

    awk -v size=$size 'BEGIN { 
            printf "%1.1f", size / 1024 / 1024 
    }'
}

cmp_size() {
    local rhs="$1"
    local lhs="$2"

    awk -v rhs="$rhs" -v lhs="$lhs" 'BEGIN { 
            average = (rhs + lhs) / 2
            difference = lhs - rhs

            if (difference != 0)
                percent = (difference / average) * 100
            else
                percent = 0

            printf "%1.1f MiB (%d%%)", difference, percent
    }'
}

add() {
    local title output input pdf_path

    while (($#)); do
        case "$1" in
            -t) shift; title="$1" ;;
            -o) shift; output="$1" ;;
            -n) noclobber=1 ;;
            -h) usage; exit ;;
            *) input="$1"
        esac
        shift
    done

    if ! is_valid_pdf "$input"; then
        printf >&2 '%s: Not a valid pdf document\n' "$input"
        exit 1
    fi

    # Make sure user-supplied directory is valid
    if ! is_valid_dir "$output"; then
        printf >&2 '%s: Cannot find directory\n' "$output"
        exit 1
    fi

    # If it's not set then fallback
    output="${output:-$HOME/docs/pdf}"

    if [[ -n "$title" ]]; then
        printf '[ /Title (%s) /DOCINFO pdfmark\n' "$title" > "$TMPDIR"/pdfmark
        pdfmark="$TMPDIR"/pdfmark
    fi

    version="$(pdf_version "$input")"

    if [[ -z "$version" ]]; then
        printf >&2 'Unable to determine pdf version\n'
        printf >&2 'Assuming latest version (%1.1f)\n' "$current_pdf_version"
        version=$current_pdf_version
    fi

    # Store for a nice comparison report at the end
    original_size="$(fsize "$input")"

    pdf_file="${input##*/}"
    pdf_parent_path="${input%/*}"

    # If the output matches the parent of the real document, use a new filename
    # instead of letting ghostscript clobber the original
    if [[ "$pdf_parent_path" == "$output" ]]; then
        forced=1
        target_output="$output/$pdf_file".tmp
    else
        target_output="$output/$pdf_file"
    fi

    run_ghostscript "$input" "$version" "$pdfmark" "$target_output"

    output_size="$(fsize "$target_output")"
    size_difference="$(cmp_size "$original_size" "$output_size")"

    printf -- >&2 'Size difference %s\n' "$size_difference"

    if ((forced & noclobber)); then
        mv -v -- "$target_output" "$input".new
    elif ((forced ^ noclobber)); then
        mv -v -- "$target_output" "$input"
    fi
}

generate() {
    local target="$1"
    local title
    local reader

    # Try to guess the pdf reader
    reader="$(xdg-mime query default application/pdf)"
    reader="${reader%.*}"

    printf 'Title=%s\n' "${title:-Library}"
    printf 'Command=exec %s\n\n' "${reader:-llpp}"

    # If we didn't get a directory just assume the current-working-directory
    if [[ ! -d "$target" ]]; then
        target=.
    fi

    shopt -s globstar

    for p in "$target"/**/*.pdf; do
        if is_valid_pdf "$p"; then
            pdf_files+=("$p")
        fi
    done

    shopt -u globstar

    for pdf in "${pdf_files[@]}"; do
        read -r _ title < <(pdfinfo "$pdf")

        if [[ -z "$title" ]]; then
            title="Warning: No title set for ${pdf##*/}"
        fi

        printf '%s=%s\n' "$title" "$pdf"
    done
}

if (($# == 0)); then
    printf >&2 'At least one argument is required\n'
    usage
    exit 1
fi

case "$@" in
    add*)
        shift; add "$@"
        exit
        ;;
    info*)
        shift; info "$@"
        exit
        ;;
    -g*)
        shift; generate "$@"
        exit
        ;;
    -h*)
        usage
        exit
        ;;
    *)
        printf >&2 'Unexpected option\n'
        usage
        exit 1
        ;;
esac
