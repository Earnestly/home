#!/usr/bin/env bash
# ghostly - Uses ghostscript to fix pdf files and generate dmenu_loader menus

# TODO
#   * Cover image thumbnail generated, rewrite dmenu_loader to support it

# Requires ghostscript (gs)
# Requires poppler (pdfinfo)
# Requires xdg-utils (xdg-mime)

# Globals
readonly TMPDIR=/tmp
readonly current_pdf_version=1.7
readonly library="$HOME"/docs/pdf

usage() {
    cat >&2 <<EOF
Usage: ghostly [options] [pdf, dir]
       ghostly add [options] <pdf>
       ghostly info [pdf, dir]

Options:
  -h     This help message.

add:
  -n     Noclobber, avoid overwriting original document. Generate a .new file instead.
  -o     Output directory (Default: HOME/docs/pdf).
  -t     Insert a title or overrides any current title if the input is the same
         file as the output.

info:
  <pdf>  Display metadata with pdfinfo.
  -g     Generate a dmenu_loader compatible menu.
  -t     Find pdf documents with missing titles.

EOF
}

is_valid_pdf() {
    local pdf="$1"

    if [[ -n "$pdf" && $(file -biL -- "$pdf") == application/pdf* ]]; then
        return 0
    else
        return 1
    fi
}

pdf_version() {
    local input="$1"

    while IFS=: read -r k v; do
        if [[ "$k" == "PDF version" ]]; then
            printf -- '%1.1f\n' "$v"
        fi
    done < <(pdfinfo "$input")
}

is_valid_dir() {
    local input="$1"

    # Make sure that what the user sets is valid
    if [[ -n "$input" && ! -d "$input" ]]; then
        return 1
    fi
}

fsize() {
    local input="$1"

    size="$(stat -c '%s' "$input")"

    awk -v size=$size 'BEGIN {
            printf "%1.1f", size / 1024 / 1024
    }'
}

cmp_size() {
    local rhs="$1"
    local lhs="$2"

    awk -v rhs="$rhs" -v lhs="$lhs" 'BEGIN {
            average = (rhs + lhs) / 2
            difference = lhs - rhs

            if (difference != 0)
                percent = (difference / average) * 100
            else
                percent = 0

            printf "%1.1f MiB (%d%%)", difference, percent
    }'
}

# Attempts to find all pdf documents
find_pdf_files() {
    local input="${1%/}"

    # If we didn't get a directory just assume the file's parent directory
    if [[ ! -d "$input" ]]; then
        input="${input%/*}"
    fi

    # If we got nothing assume the current working directory
    if [[ ! -e "$input" ]]; then
        input="$PWD"
    fi

    # Always return absolute paths
    if [[ "${input:0:1}" != / ]]; then
        input="$PWD"/"$input"
    fi

    shopt -s globstar

    for p in "$input"/**/*.pdf; do
        if is_valid_pdf "$p"; then
            printf -- '%s\n' "$p"
        fi
    done

    shopt -u globstar
}

info() {
    while (($#)); do
        case "$1" in
            -t) test=1 ;;
            -g) generate=1 ;;
            -h) usage; exit ;;
            *) input="$1"
        esac
        shift
    done

    pdf_file="${input##*/}"
    pdf_parent_path="${input%/*}"

    if ((generate)); then
        if [[ -d "$input" ]]; then
            generate "$input"
        else
            generate "$pdf_parent_path"
        fi
        exit
    fi

    if ((test)); then
        if [[ -d "$pdf_file" ]]; then
            check_for_titles "$pdf_file"
        else
            check_for_titles "$pdf_parent_path"
        fi
        exit
    fi

    if [[ -n "$input" ]]; then
        if is_valid_pdf "$input"; then
            pdfinfo "$input"
        fi
    else
        usage
        exit 1
    fi

}

add() {
    local title output input pdf_path

    while (($#)); do
        case "$1" in
            -t) shift; title="$1" ;;
            -o) shift; output="$1" ;;
            -n) noclobber=1 ;;
            -h) usage; exit ;;
            *) input="$1"
        esac
        shift
    done

    if ! is_valid_pdf "$input"; then
        printf -- >&2 '%s: Not a valid pdf document\n' "$input"
        exit 1
    fi

    # Make sure user-supplied directory is valid
    if ! is_valid_dir "$output"; then
        printf -- >&2 '%s: Cannot find directory\n' "$output"
        exit 1
    fi

    # If it's not set then fallback
    output="${output:-$library}"

    if [[ -n "$title" ]]; then
        printf -- '[ /Title (%s) /DOCINFO pdfmark\n' "$title" > "$TMPDIR"/pdfmark
        pdfmark="$TMPDIR"/pdfmark
    fi

    version="$(pdf_version "$input")"

    if [[ -z "$version" ]]; then
        printf -- >&2 'Unable to determine pdf version\n'
        printf -- >&2 'Assuming latest version (%1.1f)\n' "$current_pdf_version"
        version=$current_pdf_version
    fi

    # Store for a nice comparison report at the end
    original_size="$(fsize "$input")"

    pdf_file="${input##*/}"
    pdf_parent_path="${input%/*}"

    # If the pdf file matches the parent of the real document, use a new filename
    # instead of letting ghostscript clobber the original
    if [[ "$pdf_file" == "$pdf_parent_path" ]]; then
        forced=1
        target_output="$output/$pdf_file".tmp
    else
        target_output="$output/$pdf_file"
    fi

    run_ghostscript "$input" "$version" "$pdfmark" "$target_output"

    output_size="$(fsize "$target_output")"
    size_difference="$(cmp_size "$original_size" "$output_size")"

    printf -- >&2 'Size difference %s\n' "$size_difference"

    if ((noclobber)); then
        mv -v -- "$target_output" "$input".new
    else
        mv -v -- "$target_output" "$input"
    fi
}

generate() {
    local input="$1"
    local title
    local reader

    # Try to guess the pdf reader
    reader="$(xdg-mime query default application/pdf)"
    reader="${reader%.*}"

    printf -- 'Title=%s\n' "${title:-Library}"
    printf -- 'Command=exec %s\n\n' "${reader:-llpp}"

    mapfile -t pdf_files < <(find_pdf_files "$input")

    for pdf in "${pdf_files[@]}"; do
        read -r _ title < <(pdfinfo "$pdf")

        if [[ -z "$title" ]]; then
            title="Warning: No title set for ${pdf##*/}"
        fi

        printf -- '%s=%s\n' "$title" "$pdf"
    done
}

check_for_titles() {
    local input="${1%/}"

    mapfile -t pdf_files < <(find_pdf_files "$input")

    for pdf in "${pdf_files[@]}"; do
        read -r _ title < <(pdfinfo "$pdf")

        if [[ -z "$title" ]]; then
            printf '%s\n' "$pdf"
        fi
    done
}

run_ghostscript() {
    # WooOOooOoo

    local input="$1"
    local version="$2"
    local pdfmark="$3"
    local output="$4"
    local -a options

    # These options do their best to retain the original quality of the input
    # pdf while trying to save space where it doesn't compromise the original
    options=(-sDEVICE=pdfwrite -dBATCH -dNOPAUSE
             -dCompatibilityLevel="$version"
             -sOutputFile="$output"
             -dAutoRotatePages=/None
             -dSubsetFonts=true
             -dCompressFonts=true
             -dAutoFilterGrayImages=false
             -dAutoFilterColorImages=false
             -dGrayImageFilter=/FlateEncode
             -dMonoImageFilter=/FlateEncode
             -dColorImageFilter=/FlateEncode
             "$input")

    if [[ -n "$pdfmark" ]]; then
        options+=("$pdfmark")
    fi

    if ! command gs "${options[@]}"; then
        printf -- >&2 'gs failure (%d).\n' "$?"
        rm -f -- "$pdfmark" "$output"
    else
        rm -f -- "$pdfmark"
    fi

}

if (($# == 0)); then
    printf -- >&2 'At least one argument is required\n'
    usage
    exit 1
fi

case "$@" in
    add*)
        shift; add "$@"
        exit
        ;;
    info*)
        shift; info "$@"
        exit
        ;;
    -h*)
        usage
        exit
        ;;
    *)
        printf -- >&2 'Unexpected option\n'
        usage
        exit 1
        ;;
esac
